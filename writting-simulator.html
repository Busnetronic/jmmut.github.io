<!DOCTYPE HTML>
<html lang="es">

<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
  <meta content="utf-8">
  <title>Writting simulator</title>
  <style>
    div,
    p,
    button {
      font-size: 25px;
      text-align: center;
    }

    div,
    p {
      padding: 2% 10%;
    }

    body {
      background-color: #bbbbbb;
    }

  </style>
</head>

<body>
  <!-- size will be overwritten in the js side-->
  <canvas id="mainCanvas" width="1" height="1" style="border:1px solid #777777;">
    Your browser does not support the canvas element.
  </canvas>
  <canvas id="writingPage" width="1" height="1" style="visibility: hidden; border:1px solid #777777;">
    Your browser does not support the canvas element.
  </canvas>
  <script>
    function main() {
      const mainCanvas = document.getElementById("mainCanvas");
      mainCanvas.width = 640;
      mainCanvas.height = 480;
      const pageWidth = 200;
      const pageHeight = 200;

      const pageCanvas = document.getElementById("writingPage");
      let numberOfLetters = 0;
      mainCanvas.addEventListener('click', function (event) {
        const x = event.pageX - mainCanvas.offsetLeft;
        const y = event.pageY - mainCanvas.offsetTop;
        console.log("in click event. x: " + x + ", y: " + y);
        drawPage(pageCanvas, pageWidth, pageHeight, ++numberOfLetters);
        const ctx = mainCanvas.getContext("2d");
        ctx.drawImage(pageCanvas, 100, 200, 100 + pageWidth, 200 + pageHeight);
      }, false);
      drawPage(pageCanvas, pageWidth, pageHeight);

      const ctx = mainCanvas.getContext("2d");
      ctx.drawImage(pageCanvas, 100, 200, 100 + pageWidth, 200 + pageHeight);
    }
    function drawPage(canvas, width, height, numberOfLetters = -1) {
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#eeeeee";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#888888";
      const verticalMargin = canvas.width / 12.0;
      const horizontalMargin = canvas.height / 12.0;
      const letterWidth = horizontalMargin * 2;
      const letterHeight = letterWidth / 1.618;
      const letterVertSpacing = letterHeight / 2.0;
      const letterHorSpacing = letterWidth / 2.0;

      let posX = horizontalMargin;
      let posY = verticalMargin;
      const moveToNewLine = bakeMoveToNewLine(horizontalMargin, letterHeight, letterVertSpacing);

      for (rectangleOrCircle of rectangleOrCircleGenerator(numberOfLetters)) {
        if (wouldWriteOutsideHorizontally(posX, canvas.width, letterWidth, horizontalMargin)) {
          [posX, posY] = moveToNewLine(posX, posY);
        }
        if (wouldWriteOutsideVertically(posY, canvas.height, letterHeight, verticalMargin)) {
          break;
        }

        if (rectangleOrCircle) {
          posX = drawRectangle(ctx, posX, posY, letterWidth, letterHeight, letterHorSpacing);
        } else {
          posX = drawCircle(ctx, posX, posY, letterHeight / 2.0, letterHorSpacing);
        }
      }
    }

    /**
     * ctx: obtain from 
     * `const canvas = document.getElementById("myCanvas"); const ctx = canvas.getContext("2d");`
     */
    function drawRectangle(ctx, posX, posY, width, height, horizontalSpacing) {
      ctx.fillRect(posX, posY, width, height);
      posX += width + horizontalSpacing;
      return posX;
    }

    /**
     * ctx: obtain from 
     * `const canvas = document.getElementById("myCanvas"); const ctx = canvas.getContext("2d");`
     * posX, posY: coordinates of the top left corner of a square circumscribing the circle.
     */
    function drawCircle(ctx, posX, posY, radius, horizontalSpacing) {
      ctx.beginPath();
      ctx.arc(posX + radius, posY + radius, radius, 0, 2 * Math.PI);
      ctx.fill();
      posX += radius * 2 + horizontalSpacing;
      return posX;
    }

    /**
     * Note the inner function returns an array to be able to use destructuring assignment:
     * `[posX, posY] = moveToNewLine(posX, posY);`
     */
    function bakeMoveToNewLine(horizontalMargin, letterHeight, letterVertSpacing) {
      return (posX, posY) => {
        return [horizontalMargin, posY + letterHeight + letterVertSpacing];
      }
    }

    /**
     * Note that without arguments this will give an infinite sequence.
     * User code is expected to break the loop or provide a finite count.
     */
    function* rectangleOrCircleGenerator(count = -1) {
      let i = 0;
      while (i != count) {
        yield Math.random() < 0.5;
        i++;
      }
    }

    function wouldWriteOutsideVertically(posY, canvasHeight, letterHeight, bottomMargin) {
      return (posY + letterHeight + bottomMargin) > canvasHeight;
    }
    function wouldWriteOutsideHorizontally(posX, canvasWidth, letterWidth, rightMargin) {
      return (posX + letterWidth + rightMargin) > canvasWidth;
    }

    function test(options = {}) {
      const failedAssertions = 0;
      console.log("Starting tests...");
      function assertEquals(name, actual, expected) {
        if (actual !== expected) {
          const assertionLocation = name;
          if (!options.disableLineNumbers) {
            function getCallerLineNumber() {
              try { throw Error('') } catch (err) {
                const callerLine = err.stack.split("\n")[2].split(":");
                const lineNumber = callerLine[callerLine.length - 2];
                return lineNumber;
              }
            }
            assertionLocation += " at line " + getCallerLineNumber();
          }
          console.log("Failed test [" + assertionLocation + "]: expected " + expected
            + " but got " + actual);
          failedAssertions++;
        }
      }

      {
        let shapes = 0;
        const expectedShapes = 3;
        for (rectangleOrCircle of rectangleOrCircleGenerator(expectedShapes)) {
          shapes++;
        }
        assertEquals("limited rectangleOrCircleGenerator", shapes, expectedShapes);
      }

      {
        let shapes = 0;
        const expectedShapes = 3;
        for (rectangleOrCircle of rectangleOrCircleGenerator()) {
          shapes++;
          if (shapes >= expectedShapes) {
            break;
          }
        }
        assertEquals("infinite rectangleOrCircleGenerator", shapes, expectedShapes);
      }

      console.log("Finished tests. Number of failed assertions: " + failedAssertions);
    }

    test();
    main();
  </script>
</body>
